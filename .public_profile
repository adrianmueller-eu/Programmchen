#!/bin/bash

#############################
### ls / fd
#############################
unalias l >&/dev/null
function l() (
  ls_command=(lsd -lAF) #='ls -liAFh'
  if [[ ! -t 0 ]]; then
    IFS=$'\n'
    for f in $(cat); do
      [[ -f "$f" ]] && "${ls_command[@]}" "$@" "$f"
    done
  else
    "${ls_command[@]}" "$@"
  fi
)
alias ll=l
alias la="lsd -A" #="ls -A"
alias tl="tree -faFhpN --du"
alias td="tree -faFhpNd --du"
alias fd="fd -H"
alias fdd="fd -t d"
alias fdf="fd -t f"
function fzf() {
  command fzf -1 --no-mouse --bind='ctrl-t:toggle-preview' --exit-0 --color=hl:9,hl+:1 --preview="
if [[ -r {} ]]; then
  printf '\e[37m'
  file {} | tr -d '\n'
  printf ' ('
  stat -f '%z' {} | tr -d '\n'
  printf ' Bytes)'
  printf '\e[0m\n'
  head -n $((LINES-4)) {} #| pygmentize -O style=dracula -g
elif [[ -r {-1} ]]; then
  printf '\e[37m'
  file {-1} | tr -d '\n'
  printf ' ('
  stat -f '%z' {-1} | tr -d '\n'
  printf ' Bytes)'
  printf '\e[0m\n'
  head -n $((LINES-4)) {-1} #| pygmentize -O style=dracula -g
else
  echo 'Invalid file name: ' {}
fi" --preview-window=right "$@" #--preview-window=right:hidden
}

fdt() (
  \fd -t f -H --exclude ".git/*" --exec-batch stat -f '%c %N' "{}" \; | sort -nr | \
  while read f; do
    sec=$(echo "$f" | cut -d " " -f 1)
    printf "%s\t%s\n" "$(date -r $sec)" "$(echo "$f" | cut -d " " -f 2-)"
  done | less
)

sizeFormat() {
  if [[ $1 -ge 100000000000 ]]; then
    printf "%.0fG" $(echo "scale=1; $1/1000000000" | bc)
  elif [[ $1 -ge 10000000000 ]]; then
    printf "%.1fG" $(echo "scale=2; $1/1000000000" | bc)
  elif [[ $1 -ge 1000000000 ]]; then
    printf "%.2fG" $(echo "scale=3; $1/1000000000" | bc)
  elif [[ $1 -ge 100000000 ]]; then
    printf "%.0fM" $(echo "scale=1; $1/1000000" | bc)
  elif [[ $1 -ge 10000000 ]]; then
    printf "%.1fM" $(echo "scale=2; $1/1000000" | bc)
  elif [[ $1 -ge 1000000 ]]; then
    printf "%.2fM" $(echo "scale=3; $1/1000000" | bc)
  elif [[ $1 -ge 100000 ]]; then
    printf "%.0fK" $(echo "scale=1; $1/1000" | bc)
  elif [[ $1 -ge 10000 ]]; then
    printf "%.1fK" $(echo "scale=2; $1/1000" | bc)
  elif [[ $1 -ge 1000 ]]; then
    printf "%.2fK" $(echo "scale=3; $1/1000" | bc)
  else
    printf "$1B"
  fi
}

fdS() {
  \fd -t f -H --exclude ".git/*" --exec-batch stat -f '%z %N' "{}" | sort -nr | less
}

fdSh() {
  \fd -t f -H --exclude ".git/*" --exec-batch stat -f '%z %N' "{}" | sort -nr | \
  while read f; do
    bytes=$(echo "$f" | cut -d " " -f 1)
    printf "%s\t%s\n" "$(sizeFormat $bytes)" "$(echo "$f" | cut -d " " -f 2-)"
  done | less
}

#############################
### git
#############################
alias gst="git status | sed -n 1,2p | grep -v 'On branch' | grep -v 'Untracked'; git status --short"
alias gsti="gst --ignored"
alias ga="git add"
alias a="git add"
alias gup=git_update
# diff
alias gd="PAGER=$BREW_PREFIX/share/git-core/contrib/diff-highlight/diff-highlight git diff" # use with colors in ~/.gitconfig as described in https://www.viget.com/articles/dress-up-your-git-diffs-with-word-level-highlights/
alias gds="gd --staged"
alias gdw="PAGER= git diff --word-diff=color"
alias gdsw="gdw --staged"
alias gsh="PAGER=$BREW_PREFIX/share/git-core/contrib/diff-highlight/diff-highlight git show"
alias gshw="PAGER= git show --word-diff=color"
# ls
alias glt='git ls-tree -r --name-only "$(git rev-parse --short HEAD)"'
alias glu='git ls-files --others --exclude-standard'
alias gli="glu --ignored"
# log
unalias gl &>/dev/null
alias glf="git log --graph --abbrev-commit --decorate --format=format:'%C(red)%h%C(reset) - %C(cyan)%ar (%aD)%C(reset)%C(white)%d%C(reset)%n          %s%C(blue)%C(bold) %aN %C(dim)<%aE>%C(reset)' --all"
alias glfs="glf --stat"
alias glfp='PAGER="/opt/homebrew/share/git-core/contrib/diff-highlight/diff-highlight | less" glfs -p'
alias glfpw="glfs --patch --word-diff=color"
alias gw=glfpw
# misc
alias grh^="git reset HEAD^"
alias grh^^="git reset HEAD^^"
alias grh^2="git reset HEAD^2"
alias gurl="git config --get remote.origin.url | sed 's/\.git//;s~:~/~;s~git@~https://~;s~///~://~'"
#alias gmaintenance="git rebase --root && git reflog expire --all --expire=now && git gc --prune=now --aggressive"
alias gmaintenance="git maintenance run"

function c() ( # commit
  git status > /dev/null || return
  if [[ $(git config --show-origin user.email) != file:.git/config* ]]; then
    echo "Please set up user.name and user.email first!"
    def_name=$(git config user.name)
    printf "user.name [%s]: " "$def_name"
    read name
    [[ -z $name ]] && name=$def_name
    git config user.name "$name"

    def_email=$(git config user.email)
    printf "user.email [%s]: " "$def_email"
    read email
    [[ -z $email ]] && email=$def_email
    git config user.email "$email"
  fi

  git commit -m "$*"
)

#############################
### python
#############################
export COLUMNS
export LINES
alias python=python3.12
alias py=python
alias ipython="python -m IPython"
alias pip="python -m pip"
alias ipy=ipython
alias uva="[[ -d .venv ]] || uv venv; source .venv/bin/activate"
alias jlab="jupyter lab"
alias jnb="python -m notebook" # guarantee same python version #jupyter-notebook
alias snb="sage -n jupyter"
alias spip="sage -python -m pip"
alias ca=conda
alias caa="ca activate"
alias cad="ca deactivate"
alias cals="ca list"
alias cas="ca search"
alias cai="ca install -y"
alias cacr="ca create --clone base -n"
alias carm="ca remove --all -n"
alias bn="py -m BN"
alias sat="py -m SAT"
alias satt="py -m SAT -t"
piptop() {
   pipdeptree --python $(t python | sed -n 1p | awk '{print $3}') | grep -v '^ ' | sed 's/==.*//'
}
j() (
  [[ -z "$1" ]] && filename="playground.ipynb" || filename=$1
  [[ "$filename" != *.ipynb ]] && filename="$filename".ipynb
  touch "$filename"
  code "$filename"
  sleep 0.2
  osascript -e 'tell application "System Events" to set frontmost of the first application process whose displayed name is "Code" to true'
)
alias s=j

#############################
### hacky
#############################
alias ec='echo $?'
alias he=head
alias hist=history
alias apropos="2>/dev/null apropos"
alias shutup="osascript -e 'Set volume output volume 0'"
alias trim="sed 's/^[[:space:]]*//g' | xargs -L 1"
alias rll="sed 's/.\{250,\}/***LONG LINE HERE***/'"
alias psh="ps aux | head"
alias h="waitnet -s && howdoi"
alias rm="rm -I"
path() {
  echo $PATH | tr ':' $'\n'
}

alias pbc=pbcopy
alias pbp=pbpaste
alias vwc='pbpaste | wc'
alias al='echo "\$\$\n\\\\begin{aligned}\n  \n\\\\end{aligned}\n\$\$" | pbcopy'
alias wctex="pbpaste | sed 's/^ *//;s/^%.*//;s/[^%] *%.*//;s/^\\\\.*//;/^[^ ]*$/d' | wc -w"
alias lower="pbpaste | tr '[:upper:]' '[:lower:]' | pbcopy"
alias upper="pbpaste | tr '[:lower:]' '[:upper:]' | pbcopy"
md2h() {
  if [[ ! -t 0 ]]; then
    cat | md2html | tr -d $'\n'
  elif [[ -n $1 ]]; then
    filename=${1%.*}
    cat "$1" | md2html | tr -d $'\n' > "${filename}.html"
  else
    pbpaste | md2html | tr -d $'\n' | pbcopy
  fi
}

screen_of_color() {
  printf "\e[$1m"; for i in $(seq 1 $((COLUMNS * LINES))); do printf " "; done
}

alias red="screen_of_color 41 | less"
alias green="screen_of_color 42 | less"
alias blue="screen_of_color 44 | less"
alias white="screen_of_color 47 | less"

alias mvninit="mvn archetype:generate"
# grep
alias rg="rg --hidden --glob '!.git/*' -i"
alias g=grep
alias pg="pgrep -ila"
function pgf() { # process grep full
  pgrep -ilaf "$@" | grep -v " grep " | grep -i -- "${@: -1}"
}
# date
alias date="date -j"
alias cal="gcal --starting-day=1 --with-week-number -q DE_BY -G"
alias cal3="gcal --starting-day=1 --with-week-number -q DE_BY --force-highlighting .+ | sed -n '6,\$p'"
function bdate() {
  gdate --date="$1"
}
vcal() {
  pbpaste > $TMPDIR/event.ics
  open $TMPDIR/event.ics
  #rm $TMPDIR/event.ics
}
# files
alias q="qlmanage -p &>/dev/null"
alias mime='file -I'
alias idiff="/Applications/IntelliJ\ IDEA.app/Contents/MacOS/idea diff"
unalias diff  # omz
function diff() {
  if [[ -z "$2" || -n "$3" ]]; then
    echo "Please give exactly two arguments!"
    return 1
  fi
  if file -b --mime-type "$1" "$2" | grep "^text" >/dev/null; then
    gd --no-index "$1" "$2"
  else
    command diff "$1" "$2"
  fi
}
function cp() {
  if [[ "$1" == -* ]]; then
    command cp "$@"
  else
    command fcp "$@"
  fi
}

function hex2bytes() (
  if [[ -t 0 ]]; then
    content=$1
  else
    content=$(cat)
  fi
  content=$(printf "%s" "$content" | sed 's/[[:space:]]*//g;s/://g' | tr '[:upper:]' '[:lower:]')
  last_H=
  for (( i=0; i < ${#content}; i++ )); do
    H="${content:$i:1}"
    if [[ $H != [0-9a-f] ]]; then
      echo "Invalid character at index $i: [$H]" >&2
      return 1
    fi
    if [[ -n $last_H ]]; then
      #printf "%s: %b\n" "${last_H}${H}" "\x${last_H}${H}"
      printf "%b" "\x${last_H}${H}"
      last_H=
    else
      last_H=$H
    fi
  done

  if [[ -n $last_H ]]; then
    printf "%b" "\x${last_H}0"
  fi
)

#############################
### internet
#############################
alias airport=/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport
function wlan() {
  networksetup -setairportpower en0 $1 1> /dev/null || echo "on|off"
}
alias won="wlan on"
alias woff="wlan off"
alias blon="blueutil -p 1"
alias bloff="blueutil -p 0"
alias off="woff && bloff && pmset sleepnow >/dev/null"
alias on="won && blon"

alias firefox=/Applications/Firefox.app/Contents/MacOS/firefox
alias serve="echo http://127.0.0.1:8000 && py -m http.server"

ip() (
  if ipaddr=$(curl -sS https://ifconfig.me 2>/dev/null); then
    if ! echo "$ipaddr" | grep html &> /dev/null;then
      ssid=$(airport -I | sed -n 13p | sed 's/.*: //')
      printf "%s\t%s\t%s\n" "$(date +'%F %T')" "$ipaddr" "$ssid" >> ~/.ip_history
    fi
    echo "$ipaddr"
  else
    echo "Fetching failed"
    exit 1
  fi
)
alias wi="wiki -l de"

# youtube
alias geta=tomp3
alias yt720="yt-dlp --no-playlist -f 'bestvideo[height<=720]+bestaudio/best[height<=720]'"
alias yt1080="yt-dlp --no-playlist -f 'bestvideo[height<=1080]+bestaudio/best[height<=1080]'"
alias y=yt1080
alias ytul="alias | grep \"='yt \" | grep -v -- --cached | sed 's/alias //g; s/=.*//g'"
function ytu() (
  waitnet -s || return
  setopt NO_MONITOR # LOCAL_OPTIONS NO_NOTIFY
  [[ -n "$PROXY" ]] && echo "Using proxy ($PROXY)"
  yts=($(ytul))
  for y in "${yts[@]}"; do
    echo "$y\n$(eval $y --update)" &
  done
  wait
)
function ytr() ( # youtube recents
   yts=($(ytul))
   # collect all "recent" videos
   yt_recents=$(for ytc in "${yts[@]}"; do eval $ytc | sed "s/^/$ytc | /" | grep --color=none -E '\d\d? (hours?|days?) ago'; done)
   # output lines with "hours ago", sorted
   echo "$yt_recents" | grep --color=none -oE '\d\d? (hours?) ago' | sort -n | uniq | while read -r ago; do
       echo "$yt_recents" | grep --color=none -FE "\D$ago"
   done
   # output lines with "days ago", sorted
   echo "$yt_recents" | grep --color=none -oE '\d\d? (days?) ago' | sort -n | uniq | while read -r ago; do
       echo "$yt_recents" | grep --color=none -FE "\D$ago"
   done
)

alias be="bielefeld_events"
function curl() (
  args=("$@")
  if [[ -n "$PROXY" ]]; then
    args=(--socks5-hostname "$PROXY" "$@")
  fi
  if hash curlie &>/dev/null; then
    curlie "${args[@]}"
  else
    curl "${args[@]}"
  fi
)

function ping() {
  if [[ -z $1 ]]; then
    command ping "$PING"
  else
    command ping "$@"
  fi
}

function findDevicesInNetwork() (
  start=${1:-1}
  end=${2:-255}
  ipaddr=$(ipconfig getifaddr en0)
  echo "Your local IP: $ipaddr"
  pre=${ipaddr%.*}.
  echo "Expanding $pre{$start-$end}"
  for i in $(seq $start $end); do
    printf "$pre%d: %s\n" "$i" "$(host 192.168.1.$i)"
  done | g -v NXDOMAIN # filter all unused hosts
)

function uriencode() {
  local data
  if [[ ! -t 0 && $1 != -e ]]; then
    data=$(cat)
  elif [[ -n $1 ]]; then
    [[ $1 == -e ]] && shift
    data=$1
  else
    data=$(pbpaste)
  fi
  if hash node &>/dev/null; then
    node -e 'console.log(encodeURIComponent(process.argv[1]))' "$data"
  else
    curl -Gso /dev/null -w %{url_effective} --data-urlencode "$data" "" | cut -c 3-
  fi
}

function uridecode() {
  local data
  if [[ ! -t 0 && $1 != -e ]]; then
    data=$(cat)
  elif [[ -n $1 ]]; then
    [[ $1 == -e ]] && shift
    data=$1
  else
    data=$(pbpaste)
  fi
  node -e 'console.log(decodeURIComponent(process.argv[1]))' "$data"
}

function urldata() (
  local data
  if [[ ! -t 0 && $1 != -e ]]; then
    data=$(cat)
  elif [[ -n $1 ]]; then
    [[ $1 == -e ]] && shift
    data=$1
  else
    data=$(pbpaste)
  fi
  uridecode -e "${data#*\?}" | tr '&' '\n'
)

function fetch_dwd() ( # german weather agency / usage: $0 "state" "city"
# see https://www.dwd.de/DWD/warnungen/warnapp_gemeinden/viewer/gemeinden.js?v=2
  dwd_site=https://www.dwd.de/DE/wetter/warnungen_gemeinden/warntabellen/
  dwd_url="${dwd_site}warntab_$1_node.html"

  res=$(curl -sSi "$dwd_url") || return $?
  http_status=$(echo "$res" | sed -n '1p')
  case "$http_status" in
    *200*)
      ;;
    *404*)
      echo "Probably bad state argument: $1"
      echo "Link not found (404): $dwd_url"
      return
      ;;
    *)
      echo "Error: $http_status"
      return
      ;;
  esac

  enc_location=$(echo "$2" | recode latin1..utf8)
  wetterwarnung=$(echo "$res" | sed -n "/<h2 id=\"${enc_location}\"/,/<\/table>/p")
  if [[ -n $wetterwarnung ]]; then
    echo $wetterwarnung | tr '\n' ' ' | grep -oE "<h2 id=\"${enc_location}\".*</table>" | sed 's/<thead>.*<\/thead>//' | pup 'text{}' | xargs -L 1 echo
  else
    echo "Keine amtlichen Wetterwarnungen für ${2}."
  fi
)

function fetch_dwd2() (
  echo "ERROR: NIY"
  # 1. fetch warnings from https://www.dwd.de/DWD/warnungen/warnapp_gemeinden/json/warnings_gemeinde.json
  # 2. remove "warnWetter.loadWarnings(" and ");"
  # 3. find right polygon for desired city (stuck here)
)

function fetchPrecipitation() ( # wetter.com / usage: $0 $lat $lng
  lat=$1 lng=$2
  [[ -z $lat || -z $lng || ! "$lat" =~ ^[0-9]+.[0-9]+$ || ! "$lng" =~ ^[0-9]+.[0-9]+$ ]] && {
    echo "Usage: $0 \e[4mlat\e[0m \e[4mlng\e[0m"
    return 1;
  }

  ans=$(curl -Ss -A 'Firefox/92.0' -H "Accept-Language: en-US" -H "X-Requested-With: XMLHttpRequest" https://www.wetter.com/wetter_aktuell/nowcast_update/ --data-urlencode "lat=$lat" --data-urlencode "lng=$lng") || return $?
  res=$(node -e 'const ans=JSON.parse(process.argv[1]);
    console.log(ans.text)
    function hexToRgb(hex) {
      if (hex.charAt(0) === "#") hex = hex.substring(1);
      if (hex.length === 3) hex = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2)
      let bigint = parseInt(hex, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      }
    }
    for (let e of ans.events) {
      if (e.precipitation === 0) continue;
      let c = hexToRgb(e.color)
      e.precipitation="\\e[38;2;" + c.r + ";" + c.g + ";" + c.b + "m" + e.precipitation.toFixed(1) + "mm"
      console.log("%s\t%s (%s)\\e[0m", e.time, e.precipitation, e.short)
    }' "$ans" | sed 's/<span class="\[ text--blue-dark \]">/\\e[34;1m/g;s/<\/span>/\\e[0m/g')
  echo "$res"
)

function fetchPrecipitation2() ( # Usage: $0 <path on wetter.com>
  local res parsed
  res=$(curl -sS "https://www.wetter.com$1") || return $?
  #echo "$res" | pup '.icon-wind_arrow attr{title}' | sed -n '9,$p' | nl -v $(date +%H) | awk '{print $1 % 24 ":00\t" $2}'
  parsed=$(echo "$res" | pup '.swg-col-wv2 json{}')
  node -e 'const ans=JSON.parse(process.argv[1]); for (wind of ans) { console.log(wind.text)}' "$parsed" | nl -v $(date +%H) | awk '{
    res=$1 % 24;
    if (res < 10)
      $1="0"res":00  ";
    else
      $1=res":00  ";
    print $0
  }' | sed 's/ %/ %/;s/\([0-9] %\)/\1   /;s/\([0-9][0-9] %\)/\1 /' | recode html..latin1
)

function fetchWind() ( # Usage: $0 <path on wetter.com>
  [[ -z $1 ]] && {
    echo "Usage: $0 <path on wetter.com>"
    return 1
  }
  res=$(curl -sS "https://www.wetter.com$1") || return $?
  #echo "$res" | pup '.icon-wind_arrow attr{title}' | sed -n '9,$p' | nl -v $(date +%H) | awk '{print $1 % 24 ":00\t" $2}'
  parsed=$(echo "$res" | pup '.swg-row-wrapper')
  speed=$(echo "$parsed" | pup '.swg-col-wv3 json{}')
  direction=$(echo "$parsed" | pup '.swg-col-wi3 json{}')
  node -e '
const speed=JSON.parse(process.argv[1]);
const direction=JSON.parse(process.argv[2]);
for (i in speed) {
  console.log(direction[i].text + "\t" + speed[i].text)
}' "$speed" "$direction" | nl -v $(date +%H) | awk '{
    res=$1 % 24;
    if (res < 10)
      $1="0"res":00  ";
    else
      $1=res":00  ";
    print $0
  }' | sed -E 's/([[:alpha:]]) /\1    /;s/([[:alpha:]][[:alpha:]])  /\1 /;s/ Böen/  Böen/g'
)

function panoptoDownload() ( # TODO: seems not to work anymore
  if [[ -n $1 && $1 == *Viewer* ]]; then
    yt-dlp --no-playlist "$1"
    return
  fi
  printf "Copy (whole) page html into clipboard"
  read trash
  links=$(pbpaste | grep -o 'href="https[^"]*"' | sed 's/"//g;s/href=//g' | grep Viewer | uniq)
  echo "$links"
  printf "%d links found. Seems right?" $(echo $links | wc -l)
  read trash
  echo "$links" | xargs -L 1 yt-dlp --no-playlist
)

function dm() (
  if [[ -z $2 ]]; then
    echo "Enter a word, phrase, description, or pattern to find related words.
Usage: \e[1m$0\e[0m \e[4mkeyword\e[0m \e[4mquery\e[0m \e[4m...\e[0m

Valid \e[4mkeyword\e[0ms:
ml      \e[1mMeans like\e[0m constraint: require that the results have a meaning related to \e[4mquery\e[0m.
        This is effectively the reverse dictionary feature of OneLook [1].
sl      \e[1mSounds like\e[0m constraint: require that the results are pronounced similarly to \e[4mquery\e[0m.
sp      \e[1mSpelled like\e[0m constraint: require that the results are spelled similarly to \e[4mquery\e[0m,
        or that they match this \e[3mwildcard pattern\e[0m [2]. The most commonly used symbols
        are * (any number of characters) and ? (exactly one character).

More info: https://www.datamuse.com/api/
[1] https://onelook.com/reverse-dictionary.shtml
[2] https://onelook.com/thesaurus/#patterns"
    return 1
  fi
  keyword=$1
  shift
  res=$(curl -SsG -m 10 "https://api.datamuse.com/words" --data-urlencode "max=42" --data-urlencode "$keyword=$*") || return $?
  printf "%s" "$res" | jq -c '.[] | .word' | tr -d '"'
)

#############################
### applications
#############################
bs() {
  brew search "$@"
  brew search --desc --eval-all "$@"
}
alias bi="brew info"
alias bh="brew home"
alias J=jconsole
#alias play="spotify play"
#alias pause="spotify pause"
#alias next="spotify next"
#alias prev="spotify prev"
alias show="defaults write com.apple.finder AppleShowAllFiles YES && killall Finder"
alias hide="defaults write com.apple.finder AppleShowAllFiles NO && killall Finder"
alias lftp="sudo -s launchctl load -w /System/Library/LaunchDaemons/ftp.plist"
alias uftp='sudo -s launchctl unload -w /System/Library/LaunchDaemons/ftp.plist && sudo kill $(ps -ax | grep ftpd | grep -v grep | grep -o "\d\+" | sed -n 1p) > /dev/null 2>&1'
alias dark="osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'"

#############################
### fi*
#############################

# fip has its own script now

function fif() {
  typeset -f | grep --color=never -E ' \(\) \{?' | sed -E 's/ \(\) \{?$//g' | grep -e "$*"
}

function fia() {
  alias | sed 's/^alias //g' | grep -e "$*"
}

#############################
### files
#############################
function _pick() {
  local file_only=$1 # first argument is forced to set file_only
  shift

  local q_dirname query
  local -a fd_args

  if [[ -n "$*" ]]; then
    if [[ -f "$*" && -r "$*" ]]; then
      # existing file given
      echo "$*"
      return;
    elif [[ -d "$*" && -r "$*" ]]; then
      # existing dir given (to search in or give back)
      if [[ -n $file_only ]]; then
        q_dirname="$*"
      else
        echo "$*"
        return;
      fi
    else
      q_dirname=$(dirname "$*")
      if [[ -d "$q_dirname" && -r "$q_dirname" ]]; then
        # invalid path given, but parent exists
        query=$(basename "$*")
      else
        query="$*"
      fi
    fi
  else
    q_dirname="$PWD"
  fi

  [[ -n "$file_only" ]] && fd_args=(-t f)

  if [[ -n "$q_dirname" ]]; then # if valid dirname given, cd there
    pushd "$q_dirname" > /dev/null
  fi

  local pwd_name
  if [[ $PWD == $HOME ]]; then
    fd_args+=(-d 1)
    pwd_name="~"
  elif [[ / == "$PWD" ]]; then
    fd_args+=(-d 1)
    pwd_name=""
  elif [[ / == $(dirname "$PWD") ]]; then
    pwd_name="$PWD"
  else
    pwd_name=$(basename "$PWD")
  fi

  local picked
  picked=$(command fd -H "${fd_args[@]}" | grep -v '\.git/' | fzf --scheme=path --query="$query" --prompt="$pwd_name/ " --preview-window=right --print-query)
  local exit_code=$?
  if [[ $(printf "%s" "$picked" | wc -l) -gt 0 ]]; then # result found
    query=$(printf "%s" "$picked" | head -1)
    picked=$(printf "%s" "$picked" | tail -1)
  else
    query=$picked
  fi

  [[ "${q_dirname:${#q_dirname}-1:1}" != "/" ]] && q_dirname="$q_dirname/"
  case $exit_code in
    0) # found
      printf "%s" "$q_dirname$picked"
      ;;
    1) # not found
      printf "%s" "$q_dirname$query"
      ;;
    *)
      ;;
  esac
  return $exit_code
}

function _pick_and_execute() {
  local files
  if [[ ! -t 0 ]]; then
    files=$(cat)
  fi
  local file_only # set -f if the command can only digest files
  if [[ "-f" == $1 ]]; then
    file_only=true
    shift
  fi
  local writer # set -w if the command can create new files
  if [[ "-w" == $1 ]]; then
    writer=true
    shift
  fi

  local -a cmd=($(echo $1))
  [[ -z $cmd ]] && {
    echo "No command given"
    return 1
  }
  shift

  local -a args
  if [[ -z "$1" || "${@: -1}" == -* ]]; then
    args=($@)
    query=
  else
    args=(${@:1:$# -1})
    query="${@: -1}"
  fi

  local picked exit_code
  if [[ -z "$files" ]]; then
    picked=$(_pick "$file_only" "$query")
    exit_code=$?
  else
    local pwd_name
    if [[ $PWD == $HOME ]]; then
      pwd_name="~"
    elif [[ / == "$PWD" ]]; then
      pwd_name=""
    elif [[ / == $(dirname "$PWD") ]]; then
      pwd_name="$PWD"
    else
      pwd_name=$(basename "$PWD")
    fi
    picked=$(echo "$files" | fzf --scheme=path --query="$query" --prompt="$pwd_name/ " --preview-window=right --print-query)
    exit_code=$?
    picked=$(printf "%s" "$picked" | tail -1)
  fi
  case $exit_code in
    0) # found
      "${cmd[@]}" "${args[@]}" "$picked"
      ;;
    1) # not found
      if [[ -n $writer ]]; then
        "${cmd[@]}" "${args[@]}" "$picked"
      else
        return $exit_code
      fi
      ;;
    *)
      return $exit_code
      ;;
  esac
}

function e() {
  _pick_and_execute -f less "$@"
}

function se() {
  _pick_and_execute -f "sudo less" "$@"
}

function v() {
  _pick_and_execute -f -w vim "$@"
}

function sv() {
  _pick_and_execute -f -w "sudo vim" "$@"
}

function n() {
  _pick_and_execute -f -w nano "$@"
}

function sn() {
  _pick_and_execute -f -w "sudo nano" "$@"
}

function m() {
  _pick_and_execute -w mate "$@"
}

function sm() {
  _pick_and_execute -w "sudo mate" "$@"
}

function o() {
  _pick_and_execute open "$@"
}

function catf() {
  _pick_and_execute -f cat "$@"
}

function ccat() {
  _pick_and_execute -f "pygmentize -O style=dracula -g" "$@"
}

function cdf() {
  local picked__dir=$(fd -t d | grep -v '\.git/' | fzf --scheme=path --query="$1") || return $?
  cd "$picked__dir"
}

function rsyncit() {
  # --stats --size-only
  rsync --info=progress2 \
          --archive --crtimes `# preserve everything, except -H,-A,-X`\
          --delete --delete-delay `# but delete non-existing files` \
          --filter=':- .gitignore' \
          "$@"
}

function filecnt() {
  \fd -I0Ht d -d 1 | while IFS= read -r -d '' f; do
    printf "$f: "
    \fd -IH -t f '.*' "$f" | wc -l
  done | awk '{print $NF"\t"$0}' | sed -E 's/:.*$//g' | sort -nr
}

function cltex() (
  goal=$1
  [[ -z "$goal" && -e "main.tex" ]] && goal="main.tex"
  if [[ ! -e "$goal" || "$goal" != *.tex ]]; then
    echo "Please give a valid tex file." && return 1
  fi

  declare -i removed=0
  declare -a tokill=(-blx.bib .acn .aux .bbl .bcf .blg .dvi .fdb_latexmk .fls .glsdefs .idx .ilg .ind .ist .listing .lof .log .lot .out .out.ps .run.xml .snm .spl .xcp) # toc nav are needed
  for postfix in ${tokill[@]}; do
    file="${goal:0:$((${#goal}-4))}$postfix"
    [[ -e "$file" ]] && rm -v "$file" && ((removed++))
  done
  echo "$removed files removed"
)

function backup() (
  target=$(git config --global custom.backup)
  if [[ -z $target ]]; then
    echo "Please set target first."
    return 1;
  fi
  drive=$(echo "$target" | sed 's/^\/Volumes\///;s/\/.*$//')
  echo "Plug in $drive now"
  while [[ -z $(ls /Volumes | grep "$drive") ]]; do
    sleep 1
  done
  echo "Detected $drive!"
  while [[ ! -w "$target" ]]; do # TODO: find way to check for mounting if $target doesn't exist
    sleep 3 # wait for mounting
    if [[ ! -e "$target" ]]; then
      echo "Create backup dir $target"
      mkdir -p "$target" &>/dev/null # just in case
    fi
  done
  echo "Starting backup script now."
  echo
  caffeinate -i "$P"/backup -t "$target"
  unmount
)

function copy_custom_py_packages_depr() { # { -> make $py_usersite available for lookup
  if [[ -n $1 ]]; then
     py_usersite=$1
  else
     py_usersite=$(python -m site --user-site)
  fi
  [[ -d "$py_usersite" ]] || mkdir -p "$py_usersite"

  [[ -d "$PROJ/BN" ]] &&  cp -af "$PROJ/BN" "$py_usersite/" || echo "Failed to copy BN"
  [[ -d "$PROJ/MDP" ]] && cp -af "$PROJ/MDP" "$py_usersite/" || echo "Failed to copy MDP"
  [[ -d "$PROJ/SAT" ]] && cp -af "$PROJ/SAT" "$py_usersite/" || echo "Failed to copy SAT"
  [[ -d "$PROJ/utils" ]] && cp -af "$PROJ/utils" "$py_usersite/" || echo "Failed to copy utils"
}

function ln_update() (
  function hardLink() {
    if [[ $1 == "-P" ]]; then
      base=$P
      shift
    else
      base="$P/config"
    fi
    filename=$(basename "$1")
    fileorig="$base/$filename"
    filedest=$(dirname "$1")
    sha=$2 # if set, only copy if filedest is in original state given by sha (sha256sum)
    if [[ ! -d "$filedest" ]]; then
      echo "Destination doesn't exists! $filedest"
      return 1
    fi
    if [[ -n "$sha" ]]; then
      if [[ -e "$1" ]]; then
        sha_t=$(sha256sum "$1" | awk '{print $1}')
        # if the destination is already the new file, that's fine
        if [[ "$sha_t" == $(sha256sum "$fileorig" | awk '{print $1}') ]]; then
          printf "" # pass
        # else if target file has changed, preserve changes, but notify user
        elif [[ "$sha" != "$sha_t" ]]; then
          echo "Original $1 has changed! See: diff \"$1\" \"$fileorig\""
          return 1
        fi
      fi
    fi
    if [[ -d "$fileorig" ]]; then
      echo "Copying $filename to $filedest"
      cp -a "$fileorig" "$filedest/"
    else
      echo "Linking $filename to $filedest"
      ln -f "$fileorig" "$filedest"
    fi
  }

  if [[ -z ${P+x} ]]; then
    echo "Variable \$P not set"
    echo "Please link \$P/.profile to \$HOME manually"
    exit 1
  fi

  hardLink -P ~/.profile
  hardLink -P ~/.zshrc
  hardLink -P ~/.bashrc
  hardLink -P ~/.public_profile

  if [[ -n "$1" ]]; then
    hardLink ~/.nanorc
    hardLink /opt/homebrew/share/nano/markdown.nanorc "1667faf25ca7dd649782e3e724ef01fb01b29dcc423f34be0d67ba0a60f05b1c"
    hardLink ~/.vimrc
    hardLink ~/.Rprofile
    hardLink -P ~/.ipython/profile_default/startup/00.py

    hardLink ~/.finicky.js
    hardLink ~/.config/mpv/input.conf
    hardLink ~/.config/mpv/mpv.conf

    hardLink ~"/Library/Services/diff.workflow"
    hardLink ~"/Library/Services/diffw.workflow"
    hardLink ~"/Library/Services/diff-pdf.workflow"
    hardLink ~"/Library/Services/same?.workflow"
  fi
)

function find_encoding() (
  if [[ -z $2 ]]; then
    echo "Usage: $0 \e[4mtarget_encoding\e[0m \e[4mfile\e[0m"
    echo "See iconv -l for encodings."
    return 1
  fi
  declare -a encodings=($(iconv -l))
  to=$1
  file=$2
  testres=$(iconv -f utf8 -t "$to" "$file" 2>&1)
  if [[ $? != 0 || -z "$testres" ]]; then
     echo "$testres"
     return 1
  fi
  for enc in "${encodings[@]}"; do
    printf "$enc: " && iconv -f "$enc" -t "$to" "$file" 2>&1 && echo
  done
)

#############################
### media
#############################
function pdfpages() (
  QUIET=
  if [[ $1 == -q || $1 == -s ]]; then
    QUIET=true
    shift
  fi
  if [[ $1 == -v ]]; then
    shift # ignore
  fi

  local -a input=("$@")
  if [[ -z "$*" ]]; then
    tmpIFS=$IFS
    IFS=$'\n' input=($(fd --no-ignore-vcs -t f -d 1 '\.pdf'))
    IFS=$tmpIFS
    [[ -z "$input" ]] && echo "No .pdf file found." && return 0
  fi
  local -a files=()
  for f in "${input[@]}"; do
    [[ -r "$f" && "$f" = *.pdf ]] || continue
    files+=("$f")
  done
  if [[ "${#files[@]}" == 0 ]]; then
    echo "No .pdf file in arguments."
    return 1
  fi

  local -a pages=($(mdls -name kMDItemNumberOfPages -- "${files[@]}" | sed "s/kMDItemNumberOfPages = //g"))
  if [[ -z $QUIET ]]; then
    local COLOR=$(echo -en '\e[37m') RESET=$(echo -en '\e[0m')
    local -a idcs
    if [[ $0 == *bash* ]]; then
      idcs=($(seq 0 $((${#files[@]}-1))))
    else # zsh
      idcs=($(seq 1 ${#files[@]}))
    fi

    for idx in "${idcs[@]}"; do
      echo "${pages[idx]}: ${files[idx]}"
    done | sort -n -r | sed "s/^[0-9]*:/$COLOR&$RESET/"
    echo
  fi
  printf "%d pages found in %d files.\n" $(IFS="+"; bc <<< "${pages[*]}") ${#files[@]}
)

function pdfgrepc() {
  [[ -z "$1" ]] && return 1
  pdfgrep -c "$@" * 2>&1 | grep -v ' Could not open ' | grep -v ':0' | tr ':' ' ' | awk '{cnt=$NF; $NF=""; $0=cnt"\t"$0; print $0}' | sort -n
}
alias pdfg=pdfgrep
alias pdfgc=pdfgrepc

function meta() {
  if hash exiftool &>/dev/null; then
    if [[ -z "$1" ]]; then
      echo "Please give a file to show its metadata."
    else
      exiftool "$1"
    fi
  else
    echo "Please install exiftool before."
  fi
}

function rmmeta() {
  if hash exiftool &>/dev/null; then
    if [[ -z "$1" ]]; then
      echo "Please give a file to remove metadata from."
    else
      exiftool -all= -overwrite_original "$1"
    fi
  else
    echo "Please install exiftool before."
  fi
}

function imgx() (
  divide=$1
  shift
  local width height size mime
  for img in $@; do
    if ! mime=$(file --mime-type -E "$img"); then
      echo "$mime"
      continue
    fi
    if [[ $(printf "%s" "$mime" | awk '{print $NF}') != *image* ]]; then
      echo "Not an image file: $img"
      continue
    fi
    width=$(sips -g pixelWidth "$img" | grep -o ': \d\+' | grep -o "\d\+") || continue
    height=$(sips -g pixelHeight "$img" | grep -o ': \d\+' | grep -o "\d\+")
    size=$(du -sh "$img" | awk '{print $1}')
    echo "$img:"
    printf "    %d x %d (%s) -> " $width $height "$size"
    height=$(echo "${height}/$divide" | bc)
    new_img="${img%.*}.jpg"
    sips -s format jpeg --resampleHeight "$height" "$img" --out "$new_img" >/dev/null && {
      size=$(du -sh "$new_img" | awk '{print $1}')
      width=$(sips -g pixelWidth "$new_img" | grep -o ': \d\+' | grep -o "\d\+")
      height=$(sips -g pixelHeight "$new_img" | grep -o ': \d\+' | grep -o "\d\+")
      printf "%d x %d (%s)\n" $width $height "$size"
    }
  done
)
alias img2="imgx 2"
alias img4="imgx 4"

function ocr() (
  imagefile="${@: -1}"
  if ! hash convert &>/dev/null; then
    echo "Please make sure that convert (see imagemagick) is in your path!"
    return 1
  elif ! hash tesseract &>/dev/null; then
    echo "Please make sure that tesseract is in your path!"
    return 1
  elif [[ -f "$imagefile" ]]; then
    shift -p
    res=$(convert "$imagefile" -colorspace Gray -depth 8 -resample 200x200 -flatten -alpha Off - | tesseract "$@" - -)
    if ! echo "$res" | grep "\w" &>/dev/null; then
      echo "Oh dear, no results! :(" >&2
      echo "Maybe you should try: $0 --psm 11 $imagefile" >&2
      echo "See \e[1m$0 --help-extra\e[0m for more help." >&2
      return 2
    else
      echo "$res"
    fi
  else
    tesseract "$@"
  fi
)

function secinvideo() (
  if [[ -f $1 ]]; then
    for f in $@; do
      files+="$f"$'\0'
    done
  else
    files=$(\fd -t f -H -0 "\.(avi|flv|mkv|mov|mp4|mpeg4?|ts|webm|wmv)$" "$@")
  fi
  secs=$(printf "%s" "$files" | xargs -L 1 -0 ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 | sed 's/^/+/' | tr -d '\n' | cut -c 2- | bc)
  sec2time $secs
)

function _loudnorm() (
  local vol peak vol_change res
  vol=$(ffmpeg -hide_banner -i "$1" -af "volumedetect" -vn -sn -dn -f null /dev/null 2>&1 | \grep -o -e "max_volume.*" -e "mean_volume.*") || return $?
  echo "$vol"
  peak=$(echo "$vol" | grep "max" | grep -o -e "-\d\d\?.\d")
  if [[ "$peak" -gt -5 ]]; then
    echo "Already normalized"
    return
  fi
  vol_change=$((-peak-2))
  vol_change=$(echo $vol_change | awk '{print int($1+0.5)}')
  echo "Amplify by ${vol_change}dB"
  res=${1%.*}_normalized.${1#*.}
  ffmpeg -hide_banner -loglevel warning -stats -i "$1" -af "volume=${vol_change}dB" -c:v copy "${res}" || return
  if hash trash; then
    trash "$1"
  else
    rm "$1"
  fi
  mv "$res" "$1"
  ffmpeg -hide_banner -i "$1" -af "volumedetect" -vn -sn -dn -f null /dev/null 2>&1 | \grep -o -e "max_volume.*" -e "mean_volume.*"
)

function loudnorm() {
  for f in $@; do
    if [[ -f "$f" ]]; then
      echo "### $f"
      _loudnorm "$f" && echo || printf "\e[A\r\e[K"
    fi
  done
}

function vltomp4() (
  if [[ ! -f $1 ]]; then
    echo "Please give a video file as argument!"
    return 1
  fi

  resdir="${TMPDIR}results_mp4/"
  if [[ ! -e "$resdir" ]]; then
    mkdir "$resdir"
  elif [[ ! -d "$resdir" ]]; then
    echo "Please remove $resdir"
    return 1
  fi

  return_value=0
  for f in "$@"; do
    [[ -d "$f" ]] && continue
    resf=$(basename "$f")
    resf=${resf%.*}
    [[ -e "$f" ]] && resf="${resf} converted"
    resf=${resf}.mp4
    if [[ -e "$resf" ]]; then
      echo "Already done: $f (goal exists: $resf)"
      continue
    fi

    echo "Convert $f to $resf"
    res_path="$resdir$resf"
    ffmpeg -hide_banner -i "$f" -vcodec libx264 -tune animation -vf fps=30 -crf 28 -preset faster "$res_path"
    exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
      return_value=$exit_code
      continue
    fi
    if [[ -e "$f" ]] && hash trash &>/dev/null; then
      trash "$f" && echo "Original file moved to trash"
      mv "$res_path" "${res_path% converted.*}.mp4"
      mv "${res_path% converted.*}.mp4" .
    else
      mv "$res_path" .
      printf "Saved as $PWD/%s" "$resf"
    fi
  done
  rm -r "$resdir"
  return $return_value
)

pdf2jpg() {
  convert -density 300 -trim "$1" -quality 100 -sharpen 0x1.0 "${1%%.*}.jpg"
}

pdf2png() {
  sips -s format png --out "${1%%.*}.png" "$1"
}


#############################
### pass
#############################
alias pe="pass edit"

function pm() (
  [[ -z "$*" ]] && echo "Please give a pass-name for grabbing e-mail address." && return 1;
  p_res=$(pass "$*") || return $?

  res=$(echo "$p_res" | grep --binary-files=text -m 1 -e "^m: ")
  [[ -z $res ]] && echo "No mail address found for: $*" && return 1
  res=$(echo "$res" | cut -c 4-)

  if [[ ! -t 1 ]]; then
    echo "$res"
  else
    printf "%s" "$res" | pbcopy
    echo "$res (copied to clipboard)"
  fi
)

function pu() (
  [[ -z "$*" ]] && echo "Please give a pass-name for grabbing username." && return 1;
  p_res=$(pass "$*") || return $?

  res=$(echo "$p_res" | grep --binary-files=text -m 1 "^u: ")
  if [[ -z $res ]]; then
    res=$(echo "$p_res" | grep --binary-files=text -m 1 "^CID: ")
    if [[ -z $res ]]; then
      echo "No username found for: $*" && return 1
    else
      res=$(echo "$res" | cut -c 6-)
    fi
  else
    res=$(echo "$res" | cut -c 4-)
  fi

  if [[ ! -t 1 ]]; then
    echo "$res"
  else
    printf "%s" "$res" | pbcopy
    echo "$res (copied to clipboard)"
  fi
)

function po() (
  [[ -z "$*" ]] && echo "Please give a pass-name for grabbing online login site." && return 1;
  p_res=$(pass "$*") || return $?

  res=$(printf "%s" "$p_res" | grep --binary-files=text -m 1 -e "^o: ")
  [[ -z $res ]] && echo "No online link found for: $*" && return 1
  res=$(printf "%s" "$res" | cut -c 4-)

  if [[ "$res" != *".app" ]] && which f >/dev/null; then
    f "$res"
  else
    open "$res"
  fi
)

#############################
### math
#############################
__test_b() (
  b '1+1' || return 1 # 2
  b '2**1000' || return 1 # scientific output
  b '2^1000' || return 1 # long integer output
  b '1/sqrt(2)' || return 1 # math functions defined
  b 'log(100) * pi' || return 1 # log is base 10
  b 'ln(e^pi)' || return 1 # variables e and pi defined
  b 'binom(24,4)' || return 1 # nCr, nPr defined
  b 'is_prime(512*2^512 - 1)' || return 1 # sage is working
  b 'is_prime(1000000000000066600000000000001)' || return 1 # because primes are cool
  b 'diff(sin(x) * x^2 + cos(x) * e^(x^2))' || return 1 # sage is working 2
  b 'Fourier(e^(-x^2))' || return 1 # Fourier defined
  echo "---------------"
  echo "All tests succeeded!"
)

function randint() { # subshell resets RANDOM
  local range base
  if [[ -n $2 ]]; then
    range=$(($2 - $1))
    base=$1
  elif [[ -n $1 ]]; then
    range=$1
    base=0
  else
    range=10000
    base=0
  fi
  local size=${3:-1}
  if [ -t 0 ] && [ -t 1 ] && [[ $range -lt 16384 ]] && [[ $size -lt 100 ]]; then
    for i in $(seq 1 $size); do
      echo $((RANDOM % $range + $base))
    done
  else
    python -c "
try:
  from numpy.random import randint
  for i in randint($base, $range + $base, $size):
    print(i)
except:
  from random import randint
  for i in range($size):
    print(randint($base, $range + $base - 1))
"
  fi
}

# http://latexcalc.sourceforge.net/
function lcalc() (
  if [[ ! -t 0 ]]; then
    equation=$(cat)
  else
    equation=$(pbpaste)
  fi
  equation=$(sed 's/\\cdot/*/g' <<< "$equation")
  cat <<< "$equation"
  cat <<- EOF | latexcalc | sed -n '4p' | sed 's/^/= /'
	\documentclass[12pt]{article}
	\begin{document}
	$\solver{$equation}
	\answer
	$\end{document}
	EOF
)
alias lc=lcalc

function isprime() {
  if [[ ${#1} -le 17 ]] && (($1 < 18014398509481984)); then # 2^54
    python "$PROJ"/utils/isprime.py $1
  else
    #echo "Let's harness sage..."
    sage -c "print(is_prime($1))"
  fi
}

function pf() (
  #python -c "from utils import prime_factors; print(prime_factors($1))"
  n=$1
  factors=()
  # remove any factors of 2 first
  while (( n % 2 == 0 )); do
    factors+=(2)
    n=$((n / 2))
  done
  i=3
  while (( i * i <= n )); do
    if (( n % i )); then
      i=$((i + 2))
    else
      n=$((n / i))
      factors+=($i)
    fi
  done
  if (( n > 1 )); then
    factors+=($n)
  fi
  echo ${factors[@]}
)

function sec2time() (
    local sec=$1 min=0 hour=0 day=0
    sec=$(echo $1 | awk '{print int($1+0.5)}')
    if ((sec>59)); then
        ((min=sec/60))
        ((sec=sec%60))
        if ((min>59)); then
            ((hour=min/60))
            ((min=min%60))
            if ((hour>23)); then
                ((day=hour/24))
                ((hour=hour%24))
                 echo "$day"d "$hour"h "$min"m "$sec"s
            else
               echo "$hour"h "$min"m "$sec"s
            fi
        else
           echo "$min"m "$sec"s
        fi
    else
      echo "$sec"s
    fi
)


#############################
### misc stuff
#############################
alias showUnixTime="$BREW_PREFIX/bin/bash -c 'while true; do printf \"\\r\\e[K\$EPOCHREALTIME\"; done'"
alias weekday='case $(date +%u) in; 1) echo Monday;; 2) echo Tuesday;; 3) echo Wednesday;; 4) echo Thursday;; 5) echo Friday;; 6) echo Saturday;; 7) echo Sunday;; *) echo "Invalid week day number: $(date +%u)";; esac'
alias lsusers="dscl . list /Users | grep -v ^_"

randline() (
  s=1
  if [[ $1 =~ ^-[0-9]+$ ]]; then
    s=${1:1:4} # not more than 9999
    shift
  fi
  if [[ $2 =~ ^-[0-9]+$ ]]; then
    s=${2:1:4} # not more than 9999
  fi
  if hash shuf &>/dev/null; then
    shuf -n $s "$1"
  else
    len=$(wc -l "$1" | awk '{print $1}')
    for i in $(seq 1 $s); do
      rnd=$(randint $len)
      sed -n "${rnd}p" "$1"
    done
  fi
)

function caesar() (
  displacement=$1
  shift
  input="$*"
  if [[ -z "$input" ]]; then
    input=$(cat)
  elif [[ -f "$input" ]]; then
    input=$(cat "$input")
  fi
  if [[ -z "$displacement" || -z "$input" ]]; then
    echo "Usage: $0 displacement input"
    return 1
  fi
  python -c "from sys import argv
alphabetLower = 'abcdefghijklmnopqrstuvwxyz'
alphabetUpper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
displacement = $displacement
text = argv[1]
for character in text:
  position = alphabetLower.find(character)
  #print(character, position)
  if position > -1:
    position = (position + displacement) % len(alphabetLower)
    character = alphabetLower[position]
  else:
    position = alphabetUpper.find(character)
    if position > -1:
      position = (position + displacement) % len(alphabetUpper)
      character = alphabetUpper[position]
  print(character, end='')" "$input"
  [ -t 1 ] && echo
)

function zombiesAndStuff() {
  ps aux | awk ' $8 !~ /S/ {print $0}' | grep -v "ps aux"
}

function hexflow() (
  t=${1:-100}
  t=$((1.0/t))

  for i in $(seq 1 $LINES); do
    openssl rand -hex $((COLUMNS / 3)) | sed 's/../& /g'
  done
  while true; do
    openssl rand -hex $((COLUMNS / 3)) | sed 's/../& /g' | command grep --color=always -e "42\|$"
    sleep $t
  done
)

function battery() {
  system_profiler SPPowerDataType | grep "Charge [^I]" | awk '{print $NF" %"}' #| awk '{print $NF}' | tr '\n' ' ' | awk '{ print $1 / $2 * 100 "%"}'
}

function evilinsult() {
  hash recode &>/dev/null || {
    echo "Install recode, bitch."
    return 42
  }
  curl -sS https://evilinsult.com/generate_insult.php\?lang\=en\&type\=json | sed 's/.*"insult":"\([^"]*\)".*/\1\n/' | recode html..utf8
}

function freq() {
python -c '
# argv parsing
from sys import argv
try:
  A4 = float(argv[1])
  pitch = argv[2]
except:
  A4 = 440
  pitch = argv[1]  # e.g. C2

tone = pitch[0].upper()
octave = pitch[1:]
if len(pitch) > 1:
  if pitch[1] == "#" or pitch[1] == "b":
    tone += pitch[1]
    octave = pitch[2:]

if octave:
  octave = int(octave)
else:
  octave = 4 # default octave

#print(tone, octave)

tone_name_to_distance = {
  "C": -9,
  "C#": -8,
  "Db": -8,
  "D": -7,
  "D#": -6,
  "Eb": -6,
  "E": -5,
  "F": -4,
  "F#": -3,
  "Gb": -3,
  "G": -2,
  "G#": -1,
  "Ab": -1,
  "A": 0,
  "A#": 1,
  "Bb": 1,
  "B": 2,
  "H": 2
}

n = int(octave) - 4 + tone_name_to_distance[tone]/12 # distance in octaves
freq = A4 * 2**n
print(f"%.4f" % freq)' $1 $2
}

sound() (
  if [[ -z $1 ]]; then
    frequency=440 # A4
  elif [[ $1 =~ '^[0-9]+(\.[0-9]+)?$' ]] ; then
    frequency=$1
  else
    frequency=$(freq $1) || return 1
  fi

  play -n synth sin $frequency >&/dev/null
)

guitar() { # don't execute in subshell!
  strings=(E2 A2 D3 G3 H3 E4)
  for string in $strings; do
    printf "$string"
    sound $string
    printf "\r\e[K"
  done
}

txt2img() {
  pushd ~/Projects/latent-consistency-model >&/dev/null
  source venv/bin/activate || {
    echo "Please install requirements first:"
    echo "python3 -m pip install virtualenv && python3 -m virtualenv venv && source venv/bin/activate && pip install -r requirements.txt"
    return 1
  }

  # parse args
  if [[ -z "$1" || $1 == -* && $1 != "-h" ]]; then
    printf "Your prompt: "
    read text # don't call it "prompt", as it will set $PS1
  else
    text=$1
    shift
  fi

  open output
  trap 'deactivate; popd &>/dev/null' INT
  python main.py "$text" "$@"
  deactivate
  popd &>/dev/null
}

tts() (
  if [[ ! -t 0 ]]; then
    text=$(cat)
  elif [[ -z $1 ]]; then
    text=$(pbpaste)
  else
    text=$1
  fi
  tmpfile="${TMPDIR}audio.wav"
  python -c 'from sys import argv
from bark import SAMPLE_RATE, generate_audio
from scipy.io.wavfile import write as write_wav

text = argv[1]
print("Text:", text, end="\n\n")
audio_array = generate_audio(text)
write_wav(argv[2], SAMPLE_RATE, audio_array)
print("Audio saved to", argv[2])

# from IPython.display import Audio
# Audio(audio_array, rate=SAMPLE_RATE)
' "$text" "$tmpfile" || exit 1
  mpv "$tmpfile"
)
